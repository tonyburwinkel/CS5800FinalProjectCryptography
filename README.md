# CS5800FinalProjectCryptography
A working demonstration of network cryptography protocols.

Tony Burwinkel and Jean-Daniel Liwanga

CS5800 Algorithms 

Fall 2024

Final Project - Safe & Secure Communications Over the Network

Introduction

For our final project, we wanted to answer the question, “What algorithms and protocols are required to establish and carry out confidential network communications, and how do they work together?” To answer our question, we first needed to investigate the process required to establish and maintain these network communications. We were then able to divide the process into 4 main algorithm types: key exchange, hashing, symmetric encryption, and asymmetric encryption. We implemented key exchange and asymmetric encryption ourselves, and found pre-built Python libraries for the needed hashing and symmetric encryption algorithms. With all of the needed components in hand, we then constructed a demonstration that orchestrates the functioning of all 4 parts to show how two actors, Alice and Bob, can communicate over the network without Eve being able to listen in or interfere. 

Tony:

This question was important to me because I work in cyber security, and I've always been interested in understanding how cryptography enables us to communicate securely. I think it's incredible that humans have come up with clever ways to use mathematics and integrated circuits to keep secrets from one another. While cryptography is as old as writing, modern cryptography is inextricably tied to computing, which has caused the creation and use of algorithms never before dreamed of. Both of these cryptography algorithms were developed in the 1970s, after the advent of electronic computing– and inarguably because of the advent of electronic computing. The strength of both the Diffie Hellman key exchange and RSA key creation algorithms rely on our current computational abilities. They are solutions to problems that have arisen due to our rapidly changing modern communications paradigm. 

Jean-Daniel: 

This topic is interesting to me because it builds on the shortcomings of the Diffie Hellman key exchange protocol. After learning about the man-in-the-middle attack, I was genuinely curious about the secure protocols that prevent third parties from infiltrating private conversations. I don’t want to fully comprehend the entire process of maintaining safe and secure communications, I just want to scratch the surface of encryption. I hope to get a good grip on the methods used for enforcing privacy and understand the mathematics applied to make communication over the network truly safe and free from unwanted detection.

Analysis

Our demonstration works in 4 main sections:

RSA key generation
Diffie Hellman key exchange
Message encryption and signing
Message decryption and authentication

First, Alice and Bob need a way to find large prime numbers, so our demonstration includes an implementation of Eratosthenes sieve, a dynamic programming algorithm for finding all primes less than some number n. The sieve uses a bottom up approach to generating prime numbers, initializing an array of size n of boolean values and setting them all to True. Starting from 2, each prime is marked False and then its multiples are iterated over and marked False as well in the array. This results in all primes < n in the array being marked True. We need the sieve to generate primes for our cryptographic functions, both for the RSA key generation algorithm and Diffie Hellman key exchange algorithm, as both of these protocols rely on large prime numbers for their security and inner workings. Whenever Alice and Bob need a random prime number, they select it from the list that was generated by our sieve.
We begin the communications demonstration with RSA key generation for both Alice and Bob, who need to create Public and Private RSA keys to sign and authenticate their messages. This involves selecting 2 distinct primes p and q and finding their product n. Alice and Bob each select two primes and find their product = n, while also choosing a public exponent e. The public exponent e does not need to be unique, and so is commonly selected to be 65537 for RSA encryption. Both Alice and Bob use this e in our demonstration. These two numbers, the exponent and modulus, together constitute the public key, (n, e). Once Alice and Bob have created a public key, they then calculate Euler’s totient function on their selected n to find phi(n), which is just (p-1)(q-1), since p and q are prime (phi of any prime p = p-1). Then they each compute the modular inverse of phi(n) = d, using the extended Euclidean algorithm. They each arrive at a unique (n, d), which is their private key. So now they each have a unique public and private key that are modular inverses of each other, meaning what one key encrypts, only the other key can decrypt, and vice versa. Alice and Bob will use these keys later to sign and authenticate their messages to each other.
It is easy to generate n but hard to factorize it, especially for large primes, which is the source of RSA encryption’s strength – the computational hardness of prime factorization. The only way to forge someone’s signature is to find the d that corresponds to that person’s public n. The only way to find d is to know phi n, which we can only know if we can factorize n, or if we already know the primes p and q that make it up, as Bob and Alice do for their individual public keys. Knowing the factors of n leads them to d, and as long as they don't reveal them, the power to compute the p and q that make n up simply don't exist at this time. Our demonstration uses primes < 1000000, but in real world security applications you want n to be 1-2000 bits long, meaning a number in the neighborhood of 22000. Factoring a number this large in a reasonable amount of time is far beyond our current classical computing capabilities. 
Even given an orchestrated effort of all the computing power on earth, a number this large that breaks into just two factors is infeasible to factorize. They say that quantum cryptography will break all current classical encryption, but we are still somewhat far away from a quantum computer that could potentially do this. Considering the time complexity of prime factorization, there are a few algorithms to note. First, obviously we can brute force factorization using trial division by simply trying to divide n by all numbers < n1/2. In the case of a real RSA key, whose n should be in the 22048 range (as this is a binary number of 2048 bits), this would make the time needed to compute p and q, O(n1/2) = a worst case of 21024 operations, which would take longer than the sun has left before it burns out. Better factorization methods have been developed. Fermat’s factorization method relies on representing odd numbers as perfect squares and can factorize these numbers as quickly as O(n1/4) if p and q are close together, meaning we would find their squared difference towards the beginning rather than the end of Fermat’s algorithm’s run. Still, this yields a worst case of 2512 operations, an improvement but not enough to make a difference to us as mortals. The best factorization method currently known works only for moderately large numbers, still much smaller than 22048. This is the general number field sieve, which runs in sub-exponential time, but is still much too slow to threaten the security of true 2048-bit RSA keys.
Our RSA functions also use another concept from our lessons: repeated squaring in modular exponentiation. Python’s pow function uses repeated squaring to achieve fast modular exponentiation under the hood, which we covered in module 2. At first, I actually tried to write the RSA message digest signing and authentication functions using python’s ** operator for the exponent and % operator for the modulus, which caused the program to hang, seemingly indefinitely. Then I researched the issue and discovered it is necessary to use python’s pow function for very large numbers, specifically because it utilizes repeated squaring under the hood to calculate congruences on very large numbers quickly. When I used python’s typical operators, they were not utilizing this more efficient method. If we naively compute AB mod N by repeatedly multiplying A with itself (mod N) B times then the complexity of the algorithm is: Θ(B*lg2 N), which is exponential in B, which is what Python’s built-in operators were doing.
Implementing RSA encryption presented me with another puzzle as well, this time due to parameter size constraints, a significant topic in the area of cryptographic algorithms. Much of my time spent working on the demo code was about making sure each cryptographic algorithm received and output an appropriately sized piece of data for the next protocol to work on. When it comes to RSA encryption, one important part of its functioning, and in fact, one of RSA encryption’s limitations, is that it only works on numbers smaller than the public key’s modulus, that is, smaller than the public key’s n. This caused some headache, as I was using a real cryptographic library to hash Alice and Bob’s messages, but I was using a simplified RSA algorithm that relied on primes p and q < 1000000. This meant I needed to additionally stipulate in the hashing function that the resulting integer be put through the modulus n. This way Alice and Bob compute a hash that can be encrypted using their private RSA keys. So, in truth, in our demonstration Alice and Bob each use SHA-256 on their message to find an integer, which is then fed through the user’s public modulus to guarantee the decryption function will work properly. This does not compromise security in the context of this demonstration, that is, there is no reason Alice and Bob’s hashing functions couldn’t work this way. Since the needed variable is the sender’s public key, which is public knowledge, nothing precludes the hashing algorithm needing it to work correctly in the context of the message exchange. There is no reason Alice and Bob would need to hide this information from Eve. Eve will certainly have their public keys already, since they distributed them so people could authenticate their messages.
Next, Bob and Alice need a way to arrive at a shared secret encryption key without ever meeting in person to arrange one, so our demonstration includes an implementation of the Diffie Hellman key exchange protocol, which we covered in module 2 of the course. Alice and Bob agree on a public modulus and generator, then each chooses a private exponent. They each raise their generator to their exponent mod the modulus and send the result to the other. Each then takes the number received and raises it to their private exponent mod the modulus to arrive at the shared secret number. Our implementation uses a larger prime modulus than our coursework required, which was drawn from the Sieve. Our demonstration also takes the key exchange process further by not only having Alice and Bob arrive at the shared secret, but also having them use a (simple) key derivation function to generate an AES-128 symmetric encryption session key. This is what they would do in real life, the shared secret would serve as the input to a key derivation function which ultimately creates the session key. It was stated in our proposal that we would use premade solutions for symmetric encryption and hashing, so python’s cryptography library was used to generate an initialization vector (iv) and AES-128 encryption key from Alice and Bob’s shared secret. 
The next step in the process that Alice and Bob need to carry out is to hash their message into a digest. We used Python’s hashlib to hash Alice and Bob’s messages into the digests that they then encrypt using their private RSA keys. The specific algorithm used is Secure Hashing Algorithm (SHA)-256, and since the demonstration uses an RSA implementation with a smaller public modulus, the hash is ultimately converted to an integer and passed through the modulus so that it is the correct size for Alice and Bob’s private keys to encrypt them. This is necessary because of that one important limitation of RSA encryption: RSA keys can only encrypt chunks of data that are smaller than them. Specifically, the user’s public key must be larger than the piece of data being encrypted. 
Hashing plays several important roles in message authentication; it associates the sender’s identity with the message being sent, and it guarantees that the message received has not been altered in transit. This may seem trivial, but it is a useful thing to prove. We could imagine other ways a sender could prove who they are, like encrypting a known piece of data about themselves. For example, suppose instead of the message hash, the sender simply encrypts their own name with their private key. You could still verify that you were talking to Bob this way, since only his public key would decrypt the signature back to the correct plaintext of Bob’s name. But you wouldn’t necessarily know that the message he sent had not been tampered with. 
Since the ciphertext and the signature are separate parts, one could imagine a scenario where Eve intercepts the message from Bob and replaces it with some other message, while leaving Bob’s signature intact. Eve would need the session key to do this, but it is still theoretically possible if she has somehow compromised your key exchange process. There is a significant benefit to creating a message digest– and that is that it supports message authenticity and message integrity at the same time. Because Bob hashes his message, then encrypts that hash, we not only know that it was Bob that sent the message, we know that the message itself has not been altered, since otherwise it would produce a different hash, and Bob’s decrypted signature would not match it. If Bob had signed some other piece of information unrelated to their conversation, we would lose a significant part of this secure protocol: message integrity. So now Alice and Bob sign their messages by encrypting the digest they hashed from the plaintext, that is, they perform a modular exponentiation operation using their private key on their hashed message h: hd mod n=s, their signature. So they use their private exponent d to encrypt the message hash. 
Next, Alice and Bob each use AES-128 to encrypt their messages into ciphertext. Finally, now that Bob and Alice have created RSA keys, distributed their public keys to the world, established a session key using Diffie Hellman key exchange, encrypted their messages using this key, and created a digital signature using their private RSA keys, they are ready to send their messages. They transmit to each other:

the encrypted message (along with the needed iv) 
their signature

At this point, we are ready to decrypt and authenticate the message. Alice and Bob each decrypt the ciphertext of the message into its plaintext. Then, they each decrypt the signature they received using the sender’s public key, which has been made publicly available before the demonstration. This is a simple modular exponentiation operation on the sender’s encrypted message digest, their signature, s: se mod n=h. Notice that we are now using the public components of Alice and Bob’s RSA keys. So their public key decrypts what their private key encrypted. This operation should yield h, the sender’s original message hash. Alice and Bob now hash the decrypted plaintext of the message they decrypted with their session key. The hash that this operation yields should be the same as the h they decrypted using the sender’s public key. If the decrypted signature matches the hash, the message is authentic. Only the sender’s private key could have encrypted what their public key just decrypted. Since the message has been tied to their key via the message digest, we know that the owner of the private key must have sent this message, and we know that the message has not been altered in transit. 
This concludes the demonstration.

Conclusion

We consider our demonstration to be a success in terms of assembling and executing the protocols needed to initiate encrypted and authenticated communications. Some improvements could of course be imagined that would bring this demonstration closer to a secure cryptographic suite. A more efficient Sieve or a list of safe primes could have been used to achieve modern standards of security by ensuring primes are large and selected carefully. 
 A good implementation of Diffie Hellman is also more specific about selecting its modulus and generator, which must be selected so that the result of raising the generator to any given exponent is equally distributed about the modulus, making all n < modulus equally likely. This has to do with primitive roots, which was beyond our scope but could be undertaken. Careful sizing of the cryptographic variables could be done so that the full security of the hashing algorithm and the RSA keys could be utilized. 
We could also have undertaken the creation of a more realistic public key infrastructure of certificates. In real world scenarios, often Alice is a consumer of the internet and Bob is some server of a domain like Google.com or BankofAmerica.com. Alice is therefore interested in knowing whether or not she is corresponding with the real Bank of America, which her browser verifies through a set of certificates that ship with the browser when you install it. These certificates make up the public key infrastructure, and are the way that identity and trust are established on the modern internet. Asymmetric encryption techniques like RSA are the foundation of the Public Key Infrastructure, but they do not fully describe its complexity. Implementing a more realistic public key infrastructure by creating a certificate chain was beyond our scope, but would be another interesting layer to add to the project.

Tony: 

Seeing how the 4 kinds of algorithms worked together crystallized for me the whole process of encrypted communications from start to finish, which was really valuable to see, and made me want to dive even deeper into the algorithms we didn't implement to see how they work. Researching these algorithms has also given me an interest in number theory, why primes are special. It’s amazing that the discrete logarithm problem and prime factorization create unbreakable security due to the lack of any known algorithm to solve them quickly. I’d like to learn more about the implementation details of these protocols in the actual cipher suites that are distributed with your operating system. I’d also like to learn more about randomness and pseudorandomness in the context of computers, since these are also important components of cryptography that I didn’t get the chance to learn much about. In particular, I’m really curious how a threat actor could go about predicting what numbers your computer is likely to generate when it finds “random” primes, since your computer cannot truly achieve randomness. I find this concept confusing, but I hear about it all the time.

Jean-Daniel: 

After learning about RSA cryptography, I am starting to appreciate the little players in the world of safe and secure communication. And it’s mind-blowing to me how we can select arbitrarily large numbers and through encryption, hashing, and a few modular arithmetic operations, can arrive at public and private key components that are exact inverses of each other. While Diffie Hellman provided us with a way to hide data when sending across the network, RSA added a layer of security with authentication, preventing the occurrence of man-in-the-middle attacks. I am really glad I got to learn this, I am amazed at how modular arithmetic plays a huge role in our daily lives.
